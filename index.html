<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Communes visitées en Belgique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100%; }
    .legend {
      position: absolute; bottom: 16px; left: 16px;
      background: white; padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,.1); font: 14px/1.3 Arial, sans-serif;
    }
    .legend .row { display: flex; align-items: center; margin: 4px 0; }
    .legend .swatch { width: 14px; height: 14px; margin-right: 8px; border: 1px solid #888; }
    .leaflet-container a { color: #1d72b8; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="legend" id="legend">
    <div class="row"><span class="swatch" style="background:#2ecc71"></span>Visité</div>
    <div class="row"><span class="swatch" style="background:#e74c3c"></span>Non visité</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    function normalizeText(s) {
      return (s || "")
        .toString()
        .normalize("NFD").replace(/\p{Diacritic}/gu, "")
        .replace(/[^\w\s-]/g, "")
        .replace(/\s+/g, " ")
        .trim()
        .toLowerCase();
    }
    function normalizeName(name) { return normalizeText(name); }

    function buildColumnKeyMap(row) {
      const map = {};
      Object.keys(row).forEach(k => { map[normalizeText(k)] = k; });
      return map;
    }
    function pickField(row, keyMap, candidates) {
      for (const c of candidates) {
        const nk = normalizeText(c);
        if (keyMap[nk] !== undefined) return row[keyMap[nk]];
      }
      return undefined;
    }

    const C_COMMUNE = ["Commune"];
    const C_VISITED = ["Visitee","Visité","Visité ?","Visited","Visited ?","Visité?","visited"];
    const C_DATE = ["Date de visite","Date"];
    const C_COMMENT = ["Commentaires","Commentaire","Notes","Note","Remarques"];

    const TRUE_SET = new Set(["oui","yes","true","1","x","y","vrai","ok","visited"]);

    const NAME_FIELDS = [
      "Communes"
    ];

    const map = L.map('map', { preferCanvas: true }).setView([50.5, 4.5], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    function loadVisitedCSV() {
      return fetch('visited.csv')
        .then(r => r.text())
        .then(text => {
          const result = Papa.parse(text, { header: true, skipEmptyLines: true });
          const visitedMap = {};
          result.data.forEach(row => {
            const keyMap = buildColumnKeyMap(row);
            const rawName = pickField(row, keyMap, C_COMMUNE);
            if (!rawName) return;

            const rawVisited = pickField(row, keyMap, C_VISITED);
            const rawDate = pickField(row, keyMap, C_DATE) || "";
            const rawComment = pickField(row, keyMap, C_COMMENT) || "";

            const key = normalizeName(rawName);
            const v = String(rawVisited ?? "").toLowerCase().trim();
            const isVisited = TRUE_SET.has(v);

            visitedMap[key] = { 
              visited: isVisited, 
              date: rawDate, 
              comment: rawComment 
            };
          });
          return visitedMap;
        });
    }

    Promise.all([
      loadVisitedCSV(),
      fetch('belgium-communes.geojson').then(r => r.json())
    ]).then(([visited, geo]) => {
      const geoKeys = new Set();
      const layer = L.geoJSON(geo, {
        style: feature => {
          const props = feature.properties || {};
          let name = "";
          for (const f of NAME_FIELDS) {
            if (props[f] != null) { name = String(props[f]); break; }
          }
          const key = normalizeName(name);
          geoKeys.add(key);
          const isVisited = visited[key]?.visited || false;
          return {
            color: "#555",
            weight: 0.8,
            fillColor: isVisited ? "#2ecc71" : "#e74c3c",
            fillOpacity: 0.7
          };
        },
        onEachFeature: (feature, layer) => {
          let name = "";
          const props = feature.properties || {};
          for (const f of NAME_FIELDS) {
            if (props[f] != null) { name = String(props[f]); break; }
          }
          const key = normalizeName(name);
          const data = visited[key] || { visited: false, date: "", comment: "" };

          let popup = `<b>${name || "Commune"}</b><br>`;
          popup += data.visited ? "Visité" : "Non visité";
          if (data.date) popup += `<br>Date : ${data.date}`;
          if (data.comment) popup += `<br>${data.comment}`;

          layer.bindPopup(popup);
          layer.on('mouseover', () => layer.setStyle({ weight: 2 }));
          layer.on('mouseout', () => layer.setStyle({ weight: 0.8 }));
        }
      }).addTo(map);

      // Debugging: communes dans GeoJSON mais pas dans CSV
      console.group("DEBUG - Vérification des correspondances");
      const visitedKeys = new Set(Object.keys(visited));

      geoKeys.forEach(k => {
        if (!visitedKeys.has(k)) {
          console.warn("⚠️ Commune dans GeoJSON mais absente du CSV :", k);
        }
      });

      visitedKeys.forEach(k => {
        if (!geoKeys.has(k)) {
          console.warn("⚠️ Commune dans CSV mais absente du GeoJSON :", k);
        }
      });
      console.groupEnd();

      try { map.fitBounds(layer.getBounds(), { padding: [10, 10] }); } catch (e) {}
    }).catch(err => {
      console.error(err);
      alert("Erreur de chargement des données. Vérifie les fichiers 'visited.csv' et 'belgium-communes.geojson'.");
    });
  </script>
</body>
</html>
